#!/usr/bin/env python3

# MAKE SURE ALL OF THESE ARE NEEDED
import argparse
import getpass
import os.path
import re
import requests
import sys
import time



# MY GUESS IS WE WON'T BE USING THESE ...
def extract_nodes(nodes_file):
  """
  Given the NCBI nodes.dmp file handle, return the `parents` dictionary
  """
  parents = {}
  for line in nodes_file:
    (taxid, parent, other) = re.split('\s*\|\s*', line.strip('|\n\t '), 2)
    parents[taxid] = parent

  return parents


def extract_names(names_file):
  """
  Given the NCBI names.dmp file handle, return four dictionaries:
  `taxid_names`, `scientific_names`, `synonyms`, and `lowercase_names`
  """
  taxid_names = {}
  scientific_names = {}
  synonyms = {}
  lowercase_names = {}
  for line in names_file:
    (taxid, name, unique, kind) = re.split('\s*\|\s*', line.strip('|\n\t '), 3)
    if kind == 'scientific name':
      taxid_names[taxid] = name
      scientific_names[name] = taxid
    else:
      synonyms[name] = taxid
    lowercase_names[name.lower()] = taxid

  return taxid_names, scientific_names, synonyms, lowercase_names


def validate(name, parents, taxid_names, scientific_names, synonyms, lowercase_names):
  import random
  import string
  N = 10
  return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(N))


def write_records(records, headers, outfile, parents, taxid_names, scientific_names,
                  synonyms, lowercase_names):
  """
  Writes the given records, for which their keys are given in `headers`, to the given outfile.
  In addition, validate the population name and definition for each record and write the validation
  comments to the row corresponding to the record in the file.
  """
  validated_names = {}
  validated_defns = {}

  for record in records:
    for header in headers:
      print('"{}",'.format(record[header]), end='', file=outfile)

    # Validate a given ('populationNameReported', 'populationNamePreferred') combo at most once:
    name_key = (record['populationNameReported'], record['populationNamePreferred'])
    if name_key not in validated_names:
      validated_names[name_key] = {
        'comment_reported': validate(record['populationNameReported'], parents, taxid_names,
                                     scientific_names, synonyms, lowercase_names),
        'comment_preferred': validate(record['populationNamePreferred'], parents, taxid_names,
                                      scientific_names, synonyms, lowercase_names)}
    name_comment_reported = validated_names[name_key]['comment_reported']
    name_comment_preferred = validated_names[name_key]['comment_preferred']
    print('"{}","{}",'.format(name_comment_reported, name_comment_preferred), end='', file=outfile)
    if name_comment_reported == name_comment_preferred:
      print("Y,", end='', file=outfile)
    else:
      print("N,", end='', file=outfile)

    # Validate a given ('populationDefnitionReported', 'populationDefnitionPreferred') combo at
    # most once. Note the typo in the spelling of 'Definition' is as it is in in ImmPort.
    defn_key = (record['populationDefnitionReported'], record['populationDefnitionPreferred'])
    if defn_key not in validated_defns:
      validated_defns[defn_key] = {
        'comment_reported': validate(record['populationDefnitionReported'], parents, taxid_names,
                                     scientific_names, synonyms, lowercase_names),
        'comment_preferred': validate(record['populationDefnitionPreferred'], parents, taxid_names,
                                      scientific_names, synonyms, lowercase_names)}

    defn_comment_reported = validated_defns[defn_key]['comment_reported']
    defn_comment_preferred = validated_defns[defn_key]['comment_preferred']
    print('"{}","{}",'.format(defn_comment_reported, defn_comment_preferred), end='', file=outfile)
    if defn_comment_reported == defn_comment_preferred:
      print("Y", file=outfile)
    else:
      print("N", file=outfile)


def main():
  # Basic command-line arguments:
  parser = argparse.ArgumentParser(description='''
  Accepts as input a list of study accession IDs corresponding to Cytometry studies (fcsAnalyzed).
  For each study indicated, its details are fetched from ImmPort and the population name and
  definition reported in the study are validated using the given NCBI nodes.dmp and names.dmp files.
  The output of this script is a series of CSV files, for each given study type, reporting on the
  population name and definition used in the studies specified. In each report, the population name
  and definition reported in the study as well as the 'preferred' name and definition (i.e. the name
  and definition automatically generated by ImmPort when the study was submitted) are indcated. In
  addition to these columns, this script adds six extra columns: (a) the result of validating the
  reported population name, (b) the result of validating the preferred population name, (c) a
  comparison of the results of these two validations, (d) the result of validating the reported
  population definition, (b) the result of validating the preferred population definition, (c) a
  comparison of the results of these two validations.''')
  parser.add_argument('--username', metavar='USERNAME', type=str,
                      help='username for ImmPort API. If unspecified the script will prompt for it')
  parser.add_argument('--password', metavar='PASSWORD', type=str,
                      help='password for ImmPort API. If unspecified the script will prompt for it')
  parser.add_argument('--nodes', metavar='NODES', type=argparse.FileType('r'), required=True,
                      help='The NCBI nodes.dmp file')
  parser.add_argument('--names', metavar='NAMES', type=argparse.FileType('r'), required=True,
                      help='The NCBI names.dmp file')
  parser.add_argument('--clobber', dest='clobber', action='store_true',
                      help='If CSV files exist, overwrite them without prompting')
  parser.add_argument('--fcsAnalyzed', metavar='ID', type=str, nargs='+', required=True,
                      help='ids of Cytometry studies to validate')
  args = vars(parser.parse_args())

  # If the username and/or password have not been specified on the command line, prompt for them:
  username = args['username']
  if not username:
    username = input("Enter username for API calls to ImmPort: ")
  password = args['password']
  if not password:
    password = getpass.getpass('Enter password for API calls to ImmPort: ')

  # Get the start time of the execution for later logging the total elapsed time:
  start = time.time()

  # Get an authentication token from ImmPort:
  print("Retrieving authentication token from Immport ...")
  resp = requests.post('https://auth.immport.org/auth/token',
                       data={'username': username, 'password': password})
  if resp.status_code != requests.codes.ok:
    resp.raise_for_status()
  token = resp.json()['token']

  ##############################################
  # # Now request data for the given study ids:
  # print("Extracting NCBI data ...")
  # parents = extract_nodes(args['nodes'])
  # taxid_names, scientific_names, synonyms, lowercase_names = extract_names(args['names'])
  parents = {}
  taxid_names = {}
  scientific_names = {}
  synonyms = {}
  lowercase_names = {}
  ##############################################

  if os.path.exists('fcsAnalyzed.csv') and args['clobber'] is False:
    reply = input('fcsAnalyzed.csv exists. Do you want really want to overwrite it? (y/n): ')
    reply = reply.lower().strip()
    if reply == 'n':
      sys.exit(1)

  with open('fcsAnalyzed.csv', 'w') as outfile:
    query = ("https://api.immport.org/data/query/result/fcsAnalyzed?studyAccession={}"
             .format(','.join(args['fcsAnalyzed'])))
    print("Sending request: " + query)
    resp = requests.get(query, headers={"Authorization": "bearer " + token})
    if resp.status_code != requests.codes.ok:
      resp.raise_for_status()

    # Write the header of the CSV using the data returned:
    headers = sorted([key for key in resp.json()[0]])
    for header in headers:
      print("{},".format(header), end='', file=outfile)
    print("Comment on populationDefinitionReported,", end='', file=outfile)
    print("Comment on populationDefinitionPreferred,", end='', file=outfile)
    print("Population definition comments match", end='', file=outfile)
    print("Comment on populationNameReported,", end='', file=outfile)
    print("Comment on populationNamePreferred,", end='', file=outfile)
    print("Population name comments match", file=outfile)

    # Now write the actual data:
    for sid in args['fcsAnalyzed']:
      records = [r for r in resp.json() if r['studyAccession'] == sid]
      print("Received {} records for fcsAnalyzed ID: {}".format(len(records), sid))
      write_records(records, headers, outfile, parents, taxid_names, scientific_names,
                    synonyms, lowercase_names)

  end = time.time()
  print("Processing completed. Total execution time: {0:.2f} seconds.".format(end - start))


if __name__ == "__main__":
  main()


# Unit tests:

def test_validate():
  pass
